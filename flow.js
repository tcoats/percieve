// Generated by CoffeeScript 1.10.0
var apdex, batch, changed, coalesce, combine, contextcount, contexttime, copy, count, debounce, each, error, extend, filter, groupcount, grouptime, log, map, max, min, now, project, reduce, result, rollup, run, samplecount, sampletime, settle, split, stable, stream, sum, tagged, taggedall, taggedany, throttle, unit;

extend = require('extend');

now = function() {
  return new Date().valueOf();
};

unit = function(params) {
  var kids, res;
  kids = [];
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    return params.emit(e, function(e) {
      var i, k, len;
      for (i = 0, len = kids.length; i < len; i++) {
        k = kids[i];
        k.emit(e);
      }
      return null;
    });
  };
  if (params.copy == null) {
    res.copy = function() {
      var i, k, len, twin;
      twin = unit(params);
      for (i = 0, len = kids.length; i < len; i++) {
        k = kids[i];
        twin(k.copy());
      }
      return twin;
    };
  } else {
    res.copy = function() {
      var i, k, len, twin;
      twin = params.copy();
      for (i = 0, len = kids.length; i < len; i++) {
        k = kids[i];
        twin(k.copy());
      }
      return twin;
    };
  }
  return res;
};

stream = function() {
  return unit({
    emit: function(e, next) {
      return next(e);
    }
  });
};

filter = function(test) {
  return unit({
    emit: function(e, next) {
      if (test(e)) {
        return next(e);
      }
    }
  });
};

tagged = function(tag) {
  return unit({
    emit: function(e, next) {
      var i, len, ref, t;
      if (e.tags == null) {
        return;
      }
      ref = e.tags;
      for (i = 0, len = ref.length; i < len; i++) {
        t = ref[i];
        if (!(t === tag)) {
          continue;
        }
        next(e);
        return;
      }
    }
  });
};

taggedany = function(tags) {
  var i, len, t, tagmap;
  tagmap = {};
  for (i = 0, len = tags.length; i < len; i++) {
    t = tags[i];
    tagmap[t] = true;
  }
  return unit({
    emit: function(e, next) {
      var j, len1, ref;
      if (e.tags == null) {
        return;
      }
      ref = e.tags;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        t = ref[j];
        if (!tagmap[t]) {
          continue;
        }
        next(e);
        return;
      }
    }
  });
};

taggedall = function(tags) {
  var i, len, t, tagmap;
  tagmap = {};
  for (i = 0, len = tags.length; i < len; i++) {
    t = tags[i];
    tagmap[t] = true;
  }
  return unit({
    emit: function(e, next) {
      var count, j, len1, ref;
      if (e.tags == null) {
        return;
      }
      count = 0;
      ref = e.tags;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        t = ref[j];
        if (tagmap[t]) {
          count++;
        }
      }
      if (tags.length === count) {
        next(e);
      }
      return null;
    }
  });
};

each = function(fn) {
  return unit({
    emit: function(e, next) {
      fn(e);
      return next(e);
    }
  });
};

copy = unit({
  emit: function(e, next) {
    return next(extend(true, {}, e));
  }
});

map = function(fn) {
  return unit({
    emit: function(e, next) {
      return next(fn(e));
    }
  });
};

run = function(fn) {
  return {
    emit: function(e) {
      return fn(e);
    },
    copy: function() {
      return run(fn);
    }
  };
};

reduce = function(fn) {
  return unit({
    emit: function(events, next) {
      var current, i, item, len;
      current = null;
      for (i = 0, len = events.length; i < len; i++) {
        item = events[i];
        if (item == null) {
          continue;
        }
        if (current == null) {
          current = extend({}, item);
        }
        current = fn(current, item);
      }
      if (current != null) {
        return next(current);
      }
    }
  });
};

max = function(selector) {
  return reduce(function(current, e) {
    if (selector(e) > selector(current)) {
      return e;
    }
    return current;
  });
};

min = function(selector) {
  return reduce(function(current, e) {
    if (selector(e) < selector(current)) {
      return e;
    }
    return current;
  });
};

sum = function(selector) {
  return reduce(function(current, e) {
    if (e.metric == null) {
      e.metric = 0;
    }
    e.metric += selector(e);
    return e;
  });
};

count = reduce(function(current, e) {
  if (e.metric == null) {
    e.metric = 0;
  }
  e.metric++;
  return e;
});

contexttime = function(ms) {
  var context;
  context = [];
  return unit({
    emit: function(e, next) {
      var events;
      events = [];
      context = context.filter(function(item) {
        if ((e.time - item.time) > ms) {
          return false;
        }
        events.push(item);
        return true;
      });
      context.push(e);
      return next(events);
    },
    copy: function() {
      return contexttime(ms);
    }
  });
};

contextcount = function(count) {
  var events;
  events = [];
  return unit({
    emit: function(e, next) {
      events.push(e);
      next(events);
      if (events.length > count) {
        return events.shift();
      }
    },
    copy: function() {
      return contextcount(count);
    }
  });
};

grouptime = function(ms) {
  var drain, events, handle, kids, res;
  kids = [];
  handle = null;
  events = [];
  drain = function() {
    var i, k, len;
    if (events.length > 0) {
      for (i = 0, len = kids.length; i < len; i++) {
        k = kids[i];
        k.emit(events);
      }
      events = [];
      return handle = setTimeout(drain, ms);
    } else {
      return handle = null;
    }
  };
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    if (handle == null) {
      events = [e];
      handle = setTimeout(drain, ms);
    } else {
      events.push(e);
    }
    return null;
  };
  res.copy = function() {
    var i, k, len, twin;
    twin = grouptime(ms);
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      twin(k.copy());
    }
    return twin;
  };
  return res;
};

groupcount = function(count) {
  var events;
  events = [];
  return unit({
    emit: function(e, next) {
      events.push(e);
      if (events.length === count) {
        next(events);
        return events = [];
      }
    },
    copy: function() {
      return groupcount(count);
    }
  });
};

batch = function(count, ms) {
  var drain, events, handle, kids, res;
  kids = [];
  handle = null;
  events = [];
  drain = function() {
    var i, k, len;
    if (handle != null) {
      clearTimeout(handle);
    }
    if (events.length > 0) {
      for (i = 0, len = kids.length; i < len; i++) {
        k = kids[i];
        k.emit(events);
      }
      events = [];
      return handle = setTimeout(drain, ms);
    } else {
      return handle = null;
    }
  };
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    if (handle == null) {
      events = [e];
      handle = setTimeout(drain, ms);
    } else {
      events.push(e);
    }
    if (events.length === count) {
      drain();
    }
    return null;
  };
  res.copy = function() {
    var i, k, len, twin;
    twin = batch(count, ms);
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      twin(k.copy());
    }
    return twin;
  };
  return res;
};

sampletime = function(ms) {
  var last;
  last = null;
  return unit({
    emit: function(e, next) {
      if (last == null) {
        last = e.time;
        return;
      }
      if (e.time - last > ms) {
        next(e);
        return last = e.time;
      }
    },
    copy: function() {
      return sampletime(ms);
    }
  });
};

samplecount = function(count) {
  var index;
  index = 0;
  return unit({
    emit: function(e, next) {
      index++;
      if (index === count) {
        next(e);
        return index = 0;
      }
    },
    copy: function() {
      return samplecount(count);
    }
  });
};

changed = function(selector, initial) {
  var previous;
  previous = initial;
  return unit({
    emit: function(e, next) {
      var current;
      current = selector(e);
      if (previous !== current) {
        next(e);
      }
      return previous = current;
    },
    copy: function() {
      return changed(selector, initial);
    }
  });
};

settle = function(ms) {
  var drain, event, handle, kids, res;
  kids = [];
  handle = null;
  event = null;
  drain = function() {
    var i, k, len;
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      k.emit(event);
    }
    event = null;
    return handle = null;
  };
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    if (handle != null) {
      clearTimeout(handle);
    }
    event = e;
    handle = setTimeout(drain, ms);
    return null;
  };
  res.copy = function() {
    var i, k, len, twin;
    twin = settle(ms);
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      twin(k.copy());
    }
    return twin;
  };
  return res;
};

stable = function(ms, selector, initial) {
  var event, kids, previous, res;
  previous = initial;
  kids = [];
  event = null;
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    var current, i, k, len;
    if ((event != null) && e.time - event.time > ms) {
      event = null;
    }
    if (event === null) {
      event = e;
      previous = selector(e);
      return;
    }
    current = selector(e);
    if (previous === current) {
      for (i = 0, len = kids.length; i < len; i++) {
        k = kids[i];
        k.emit(e);
      }
      return;
    }
    previous = current;
    event = e;
  };
  res.copy = function() {
    var i, k, len, twin;
    twin = stable(ms, selector);
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      twin(k.copy());
    }
    return twin;
  };
  return res;
};

debounce = function(ms) {
  var last;
  last = null;
  return unit({
    emit: function(e, next) {
      if (last == null) {
        last = e.time;
        return next(e);
      } else if (e.time - last > ms) {
        last = e.time;
        return next(e);
      }
    },
    copy: function() {
      return debounce(ms);
    }
  });
};

combine = function(streams) {
  var i, kids, len, res, s;
  kids = [];
  for (i = 0, len = streams.length; i < len; i++) {
    s = streams[i];
    s({
      emit: function(e) {
        return res.emit(e);
      }
    });
  }
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    var j, k, len1;
    for (j = 0, len1 = kids.length; j < len1; j++) {
      k = kids[j];
      k.emit(e);
    }
    return null;
  };
  res.copy = function() {
    var j, k, len1, twin;
    twin = combine(streams);
    for (j = 0, len1 = kids.length; j < len1; j++) {
      k = kids[j];
      twin(k.copy());
    }
    return twin;
  };
  return res;
};

split = function(selector) {
  var kids, res, streams;
  kids = [];
  streams = {};
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    var i, k, len, ref, value;
    value = selector(e);
    if (streams[value] == null) {
      streams[value] = kids.map(function(k) {
        return k.copy();
      });
    }
    ref = streams[value];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      k.emit(e);
    }
    return null;
  };
  res.copy = function() {
    var i, k, len, twin;
    twin = split(selector);
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      twin(k.copy());
    }
    return twin;
  };
  return res;
};

coalesce = function(selector, ms) {
  var drain, handle, kids, lake, res;
  kids = [];
  handle = null;
  lake = {};
  drain = function() {
    var current, e, events, i, k, key, len;
    current = now();
    events = [];
    for (key in lake) {
      e = lake[key];
      if ((e.ttl == null) || e.time + e.ttl < current) {
        events.push(extend({}, e, {
          state: 'expired'
        }));
        delete lake[key];
        continue;
      }
      events.push(e);
    }
    if (events.length > 0) {
      for (i = 0, len = kids.length; i < len; i++) {
        k = kids[i];
        k.emit(events);
      }
      return handle = setTimeout(drain, ms);
    } else {
      return handle = null;
    }
  };
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    lake[selector(e)] = e;
    if (handle == null) {
      handle = setTimeout(drain, ms);
    }
    return null;
  };
  res.copy = function() {
    var i, k, len, twin;
    twin = coalesce(selector, ms);
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      twin(k.copy());
    }
    return twin;
  };
  return res;
};

project = function(predicates) {
  var events, kids, res;
  kids = [];
  events = predicates.map(function(predicate) {
    return null;
  });
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    var i, index, j, k, len, len1, predicate;
    for (index = i = 0, len = predicates.length; i < len; index = ++i) {
      predicate = predicates[index];
      if (predicate(e)) {
        events[index] = e;
      }
    }
    for (j = 0, len1 = kids.length; j < len1; j++) {
      k = kids[j];
      k.emit(events);
    }
    events = events.map(function(item) {
      if ((item == null) || (item.ttl == null) || item.time + item.ttl < e.time) {
        return null;
      }
      return item;
    });
    return null;
  };
  res.copy = function() {
    var i, k, len, twin;
    twin = project(predicates);
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      twin(k.copy());
    }
    return twin;
  };
  return res;
};

rollup = function(count, ms) {
  var drain, events, handle, kids, res;
  kids = [];
  handle = null;
  events = [];
  drain = function() {
    var i, k, len;
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      k.emit(events);
    }
    events = [];
    return handle = null;
  };
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    var i, k, len;
    if (handle != null) {
      events.push(e);
      return;
    }
    events.push(e);
    events = events.filter(function(item) {
      return (e.time - item.time) < ms;
    });
    if (events.length <= count) {
      for (i = 0, len = kids.length; i < len; i++) {
        k = kids[i];
        k.emit([e]);
      }
      return;
    }
    handle = setTimeout(drain, ms + events[0].time - e.time);
    return null;
  };
  res.copy = function() {
    var i, k, len, twin;
    twin = rollup(count, ms);
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      twin(k.copy());
    }
    return twin;
  };
  return res;
};

apdex = function(issatisfied, istolerated, ms) {
  var drain, events, handle, kids, res;
  kids = [];
  handle = null;
  events = [];
  drain = function() {
    var e, i, item, j, k, len, len1;
    if (events.length === 0) {
      handle = null;
      return;
    }
    e = extend({}, events[events.length - 1]);
    e.time = now();
    e.satisfied = 0;
    e.tolerated = 0;
    for (i = 0, len = events.length; i < len; i++) {
      item = events[i];
      if (issatisfied(item)) {
        e.satisfied++;
      } else if (istolerated) {
        e.tolerated++;
      }
    }
    e.apdex = (e.satisfied + e.tolerated / 2) / events.length;
    for (j = 0, len1 = kids.length; j < len1; j++) {
      k = kids[j];
      k.emit(e);
    }
    events = [];
    return handle = setTimeout(drain, ms);
  };
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    if ((e != null ? e.state : void 0) === 'expired') {
      return;
    }
    events.push(e);
    if (handle == null) {
      handle = setTimeout(drain, ms);
    }
    return null;
  };
  res.copy = function() {
    var i, k, len, twin;
    twin = apdex(count, ms);
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      twin(k.copy());
    }
    return twin;
  };
  return res;
};

throttle = function(count, ms) {
  var drain, events, handle, kids, res;
  kids = [];
  handle = null;
  events = [];
  drain = function() {
    events = [];
    return handle = null;
  };
  res = function(k) {
    kids.push(k);
    return res;
  };
  res.emit = function(e) {
    var i, k, len;
    if (handle != null) {
      events.push(e);
      return;
    }
    events.push(e);
    events = events.filter(function(item) {
      return (e.time - item.time) < ms;
    });
    if (events.length <= count) {
      for (i = 0, len = kids.length; i < len; i++) {
        k = kids[i];
        k.emit(e);
      }
      return;
    }
    handle = setTimeout(drain, ms + events[0].time - e.time);
    return null;
  };
  res.copy = function() {
    var i, k, len, twin;
    twin = throttle(count, ms);
    for (i = 0, len = kids.length; i < len; i++) {
      k = kids[i];
      twin(k.copy());
    }
    return twin;
  };
  return res;
};

log = {
  emit: function(e) {
    return console.log(e);
  },
  copy: function() {
    return log;
  }
};

error = {
  emit: function(e) {
    return console.error(e);
  },
  copy: function() {
    return error;
  }
};

result = stream;

result.extend = extend;

result.unit = unit;

result.log = log;

result.error = error;

result.now = now;

result.seconds = function(n) {
  return n * 1000;
};

result.minutes = function(n) {
  return n * 60000;
};

result.hours = function(n) {
  return n * 360000;
};

result.days = function(n) {
  return n * 8640000;
};

result.stream = stream;

result.filter = filter;

result.tagged = tagged;

result.taggedany = taggedany;

result.taggedall = taggedall;

result.each = each;

result.copy = copy;

result.map = map;

result.run = run;

result.reduce = reduce;

result.max = max;

result.min = min;

result.sum = sum;

result.count = count;

result.contexttime = contexttime;

result.contextcount = contextcount;

result.grouptime = grouptime;

result.groupcount = groupcount;

result.batch = batch;

result.coalesce = coalesce;

result.project = project;

result.rollup = rollup;

result.apdex = apdex;

result.sampletime = sampletime;

result.samplecount = samplecount;

result.changed = changed;

result.settle = settle;

result.stable = stable;

result.debounce = debounce;

result.throttle = throttle;

result.combine = combine;

result.split = split;

module.exports = result;
